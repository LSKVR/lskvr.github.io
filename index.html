<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>X3DOM Beach — Enlarged Models & Smooth Camera</title>
  <link rel="stylesheet" href="https://www.x3dom.org/download/x3dom.css">
  <script src="https://www.x3dom.org/download/x3dom.js"></script>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
    }

    #x3d-container {
      width: 100%;
      height: 100vh;
      background: skyblue;
      display: block
    }

    .hint {
      position: fixed;
      left: 10px;
      top: 10px;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px 12px;
      border-radius: 6px;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 13px;
      z-index: 10
    }

    .note {
      position: fixed;
      right: 10px;
      top: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 12px;
      z-index: 10
    }

    .panel {
      position: fixed;
      left: 10px;
      bottom: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 10px;
      border-radius: 6px;
      max-height: 60vh;
      overflow: auto;
      font-family: Arial, Helvetica, sans-serif;
      font-size: 13px;
      z-index: 10;
    }

    .panel h4 {
      margin: 0 0 6px 0;
      font-size: 14px;
    }

    .panel button {
      margin: 2px;
      padding: 4px 6px;
      font-size: 12px;
    }
  </style>
</head>

<body style="background:skyblue;">
  <div class="hint">방향키: 이동 · 회전 / Shift: 빠르게 이동</div>
  <div class="note"></div>

  <div class="panel" id="modelPanel" style="display:none;">
    <h4>모델 목록 (클릭하면 이동)</h4>
    <div id="modelButtons"></div>
  </div>

  <x3d id="x3d-container">
    <scene id="scene">
      <background backUrl="img/sky_back.jpg" frontUrl="img/sky_front.jpg" leftUrl="img/sky_left.jpg"
        rightUrl="img/sky_right.jpg" topUrl="img/sky_top.jpg" bottomUrl="img/sky_bottom.jpg">
      </background>

      <!-- 조명을 약하게 수정 -->
      <directionalLight direction='-0.4 -1 -0.2' intensity='0.2' color='1 0.98 0.95'></directionalLight>
      <ambientLight intensity='0.15' color='1 1 1'></ambientLight>

      <viewpoint id="playerView" position="0 15 10" orientation="0 1 0 3.14159"></viewpoint>

      <transform translation="0 0 0">
        <shape>
          <appearance>
            <imageTexture url='img/sand.jpg'></imageTexture>
            <material specularColor='0.2 0.15 0.1' diffuseColor='1 0.95 0.85'></material>
          </appearance>
          <box size='3000 0.2 3000'></box>
        </shape>
      </transform>

      <transform translation="0 -0.1 -600">
        <shape>
          <appearance>
            <material diffuseColor='0.02 0.35 0.6' specularColor='0.2 0.5 0.7' shininess='0.4' transparency='0.0'>
            </material>
          </appearance>
          <box size='3000 0.1 800'></box>
        </shape>
      </transform>

      <group id="envGroup"></group>
    </scene>
  </x3d>

  <script>
    (function () {
      const view = document.getElementById('playerView');
      const envGroup = document.getElementById('envGroup');
      const modelPanel = document.getElementById('modelPanel');
      const modelButtons = document.getElementById('modelButtons');

      let pos = { x: 0, y: 15, z: 10 };
      let yaw = Math.PI;
      let move = { forward: false, backward: false, left: false, right: false };
      let speedMultiplier = 1;
      const moveSpeed = 225.0;
      const rotateSpeed = 1.8;

      function applyView() {
        const limit = 1400; // 이동 제한 확장
        if (pos.x > limit) pos.x = limit;
        if (pos.x < -limit) pos.x = -limit;
        if (pos.z > limit) pos.z = limit;
        if (pos.z < -limit) pos.z = -limit;
        if (pos.y < 1.0) pos.y = 1.0;
        view.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
        view.setAttribute('orientation', `0 1 0 ${yaw}`);
      }
      applyView();

      let last = performance.now();
      function tick(now) {
        const dt = (now - last) / 1000; last = now;
        if (move.left) yaw += rotateSpeed * dt;
        if (move.right) yaw -= rotateSpeed * dt;
        let dir = 0;
        if (move.forward) dir -= 1;
        if (move.backward) dir += 1;
        if (dir !== 0) {
          const s = moveSpeed * speedMultiplier * dt * dir;
          const fx = Math.sin(yaw);
          const fz = Math.cos(yaw);
          pos.x += fx * s;
          pos.z += fz * s;
        }
        applyView();
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);

      window.addEventListener('keydown', (e) => {
        switch (e.key) {
          case 'ArrowUp': move.forward = true; break;
          case 'ArrowDown': move.backward = true; break;
          case 'ArrowLeft': move.left = true; break;
          case 'ArrowRight': move.right = true; break;
          case 'Shift': speedMultiplier = 3; break;
        }
      });
      window.addEventListener('keyup', (e) => {
        switch (e.key) {
          case 'ArrowUp': move.forward = false; break;
          case 'ArrowDown': move.backward = false; break;
          case 'ArrowLeft': move.left = false; break;
          case 'ArrowRight': move.right = false; break;
          case 'Shift': speedMultiplier = 1; break;
        }
      });

      function createTransform(x, z, inner) {
        const t = document.createElement('transform');
        t.setAttribute('translation', `${x} 0 ${z}`);
        t.innerHTML = inner;
        return t;
      }

      function createTree(x, z, scale = 1) {
        const t = document.createElement('transform');
        t.setAttribute('translation', `${x} 0 ${z}`);
        t.setAttribute('scale', `${scale * 3} ${scale} ${scale}`);
        const inline = document.createElement('Inline');
        inline.setAttribute('url', 'tree_simple.x3d');
        t.appendChild(inline);
        return t;
      }

      function createHouse(x, z, scale = 1) {
        const t = document.createElement('transform');
        t.setAttribute('translation', `${x} 0 ${z}`);
        t.setAttribute('scale', `${scale * 3} ${scale} ${scale}`);
        const inline = document.createElement('Inline');
        inline.setAttribute('url', 'house_simple.x3d');
        t.appendChild(inline);
        return t;
      }

      function createBench(x, z, scale = 1) {
        const t = document.createElement('transform');
        t.setAttribute('translation', `${x} 0 ${z}`);
        t.setAttribute('scale', `${scale} ${scale} ${scale}`);
        const inline = document.createElement('Inline');
        inline.setAttribute('url', 'bench_simple.x3d');
        t.appendChild(inline);
        return t;
      }

      function scatterFixedMore() {
        const treePositions = [
          [-400, 300], [100, -250], [200, 200], [-150, -350], [300, 100],
          [-250, 0], [0, -200], [350, -300], [-300, 250], [150, 150],
          [-200, 320], [250, -270], [180, 150], [-120, -330], [280, 50],
          [-270, 50], [50, -180], [320, -250], [-250, 200], [100, 180]
        ];
        treePositions.forEach(([x, z]) => {
          envGroup.appendChild(createTree(x, z, 2));
        });

        const housePositions = [
          [-300, -200], [260, -220], [220, 260],
          [-220, 150], [180, -180], [100, 220]
        ];
        housePositions.forEach(([x, z]) => {
          envGroup.appendChild(createHouse(x, z, 5.2));
        });

        envGroup.appendChild(createBench(40, -120, 1));
        envGroup.appendChild(createBench(80, -140, 1));
        envGroup.appendChild(createBench(-60, -130, 1));
      }

      scatterFixedMore();

      (function createWavePlane() {
        const t = document.createElement('transform');
        t.setAttribute('translation', '0 -0.05 -420');
        t.innerHTML = `
        <shape>
          <appearance>
            <material diffuseColor='0.02 0.35 0.6' specularColor='0.5 0.6 0.7' shininess='0.8' transparency='0.0'></material>
          </appearance>
          <box size='2200 0.02 600'></box>
        </shape>
      `;
        envGroup.appendChild(t);
      })();

      // --- 외부 X3D 모델 ---
      function loadExternalX3DObjectsUniform() {
        const files = [
          "redBox.x3d", "cRoss.x3d", "cone.x3d", "cylinder.x3d", "sphere.x3d",
          "shape.x3d", "cylinder_three.x3d", "pointSet.x3d",
          "pointSetApp.x3d", "indexedLine.x3d", "cubeDot.x3d",
          "indexedFaceSet.x3d", "indexedFaceSet_box.x3d", "indexedFaceSet_tr.x3d",
          "text3D.x3d", "translation.x3d", "scale.x3d", "rotation.x3d",
          "center.x3d", "defUse.x3d", "bench.x3d",
          "color.x3d", "color2.x3d",
          "ImageTexture.x3d", "ImageRotation.x3d",
          "TextureCodinate.x3d", "TextureCodinate2.x3d",
          "anchor.x3d"
        ];
        const N = files.length;
        if (N === 0) return;

        const cols = Math.ceil(Math.sqrt(N));
        const rows = Math.ceil(N / cols);
        const AREA = 2400; // 간격 넓힘
        const HALF = AREA / 2;
        const cellW = AREA / cols;
        const cellH = AREA / rows;
        modelButtons.innerHTML = '';
        modelPanel.style.display = 'block';


        for (let i = 0; i < N; i++) {
          const file = files[i];
          const row = Math.floor(i / cols);
          const col = i % cols;
          const x = -HALF + cellW * col + cellW / 2;
          const z = -HALF + cellH * row + cellH / 2;
          const t = document.createElement('transform');

          // ↑ 위치 수정: 4 -> 15 (더 높이 띄움)
          const yHeight = 15;
          t.setAttribute('translation', `${x} ${yHeight} ${z}`);
          t.setAttribute('scale', `2 2 2`); // 크기 2배

          const inline = document.createElement('Inline');
          inline.setAttribute('url', file);
          t.appendChild(inline);

          t.setAttribute('id', `model_${i}`);
          envGroup.appendChild(t);


          const btn = document.createElement('button');
          btn.textContent = file.replace('.x3d', '');

          // 클릭 시 부드러운 카메라 이동
          btn.addEventListener('click', () => {
            const targetPos = { x: x, y: yHeight, z: z + 20 }; // 모델 앞쪽 (거리도 살짝 늘림)
            const startPos = { ...pos };
            const duration = 1000; // 1초
            const startTime = performance.now();

            function animate(now) {
              const t = Math.min((now - startTime) / duration, 1);
              pos.x = startPos.x + (targetPos.x - startPos.x) * t;
              pos.y = startPos.y + (targetPos.y - startPos.y) * t;
              pos.z = startPos.z + (targetPos.z - startPos.z) * t;
              applyView();
              if (t < 1) requestAnimationFrame(animate);
            }
            requestAnimationFrame(animate);
          });

          modelButtons.appendChild(btn);
        }
      }

      loadExternalX3DObjectsUniform();
      console.log('Beach scene created with enlarged models and smooth camera movement.');
    })();
  </script>
</body>

</html>